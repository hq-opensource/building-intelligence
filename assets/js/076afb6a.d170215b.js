"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9704],{60:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"Home Assistant Interface/control","title":"Control","description":"The control subpackage is the core of the ha-device-interface service, providing the necessary tools to manage and interact with smart home devices. It is composed of two main modules: interface.py and subscriber.py.","source":"@site/docs/Home Assistant Interface/control.md","sourceDirName":"Home Assistant Interface","slug":"/Home Assistant Interface/control","permalink":"/docs/Home Assistant Interface/control","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"HA Device Interface","permalink":"/docs/Home Assistant Interface/intro"},"next":{"title":"Introduction to the Common Package","permalink":"/docs/common/common-intro"}}');var i=s(4848),o=s(8453);const c={sidebar_position:2},r="Control",a={},d=[{value:"<code>interface.py</code>",id:"interfacepy",level:2},{value:"<code>subscriber.py</code>",id:"subscriberpy",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"control",children:"Control"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"control"})," subpackage is the core of the ",(0,i.jsx)(t.code,{children:"ha-device-interface"})," service, providing the necessary tools to manage and interact with smart home devices. It is composed of two main modules: ",(0,i.jsx)(t.code,{children:"interface.py"})," and ",(0,i.jsx)(t.code,{children:"subscriber.py"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"interfacepy",children:(0,i.jsx)(t.code,{children:"interface.py"})}),"\n",(0,i.jsxs)(t.p,{children:["This module defines the contract for device control through the abstract base class ",(0,i.jsx)(t.code,{children:"DeviceInterface"}),". This class ensures that all device implementations adhere to a common structure, which includes the following methods:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"get(params: dict) -> float"})}),": Retrieves the current state of a device."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"set(params: dict) -> None"})}),": Sets a new state for a device."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The module also provides two concrete implementations of the ",(0,i.jsx)(t.code,{children:"DeviceInterface"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"HomeAssistantDeviceInterface"})}),": Interacts with the Home Assistant API to control devices. It handles the communication details, such as authentication and request formatting, allowing for seamless integration with a Home Assistant instance."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"MockDeviceInterface"})}),": A mock implementation used for testing purposes. It simulates the behavior of a real device, which is useful for development and debugging without requiring a physical device."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"subscriberpy",children:(0,i.jsx)(t.code,{children:"subscriber.py"})}),"\n",(0,i.jsxs)(t.p,{children:["This module is responsible for handling incoming device control requests. It sets up a Redis subscriber that listens on dedicated channels for ",(0,i.jsx)(t.code,{children:"get"})," and ",(0,i.jsx)(t.code,{children:"set"})," commands. When a message is received, the subscriber instantiates the appropriate device interface\u2014based on the application's configuration\u2014and executes the requested command."]}),"\n",(0,i.jsx)(t.p,{children:"This architecture allows for a decoupled and scalable system where new device types can be easily added without modifying the core logic of the application."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>r});var n=s(6540);const i={},o=n.createContext(i);function c(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);